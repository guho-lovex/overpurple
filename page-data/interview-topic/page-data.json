{"componentChunkName":"component---src-components-blog-post-layout-tsx","path":"/interview-topic/","result":{"data":{"site":{"siteMetadata":{"title":"overpurple - A blog by GuHo"}},"markdownRemark":{"id":"544d0c45-84c1-5b30-8d46-d4f1d59d75d0","excerpt":"这是一篇汇总前端进阶面试题的文章，希望我能将这些知识汇总到这里，让自己看到后能更加的了解和熟悉这类知识点。 Js事件循环(Event Loop) 浏览器Event Loop JavaScript 有一个基于事件循环（event loop…","html":"<p>这是一篇汇总前端进阶面试题的文章，希望我能将这些知识汇总到这里，让自己看到后能更加的了解和熟悉这类知识点。</p>\n<details open>\n<summary>\n<h2 id=\"js事件循环event-loop\" style=\"position:relative;\"><a href=\"#js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFevent-loop\" aria-label=\"js事件循环event loop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Js事件循环(Event Loop)</h2>\n</summary>\n<details open>\n<summary>\n<h3 id=\"浏览器event-loop\" style=\"position:relative;\"><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8event-loop\" aria-label=\"浏览器event loop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>浏览器Event Loop</h3>\n</summary>\n<p>JavaScript 有一个基于事件循环（event loop）的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列的子任务。</p>\n<h4 id=\"javascript-的运行机制\" style=\"position:relative;\"><a href=\"#javascript-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6\" aria-label=\"javascript 的运行机制 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaScript 的运行机制</h4>\n<ol>\n<li>所有同步任务都在主线程上执行，形成一个<strong>执行栈</strong></li>\n<li>主线程外还有一个 <strong>任务队列</strong>。只要异步任务有了运行结果，就在任务队列中放置一个事件</li>\n<li>在 执行栈 中的所有同步任务执行完毕，就会读取 任务队列，看看里面有哪些事件。那些对应的异步任务于是结束等待状态，进入执行栈开始执行。</li>\n<li>主线程不断的重复以上三步，直到全部执行完成。</li>\n</ol>\n<p>概括：调用栈中的同步任务都执行完毕，栈内被清空，届时主线程空闲了，就回去 任务队列 中按顺序读取一个任务放进栈中执行。每次栈内被清空，都会去读取任务队列，看有没有任务，有就读取执行，一直循环读取-执行的操作。</p>\n<p><br> <strong>一个事件循环中有一个或多个任务队列</strong></p>\n<h4 id=\"javascript-中有两种异步任务\" style=\"position:relative;\"><a href=\"#javascript-%E4%B8%AD%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1\" aria-label=\"javascript 中有两种异步任务 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>javaScript 中有两种异步任务</h4>\n<ol>\n<li><strong>宏任务</strong>（macrotask）：</li>\n</ol>\n<p>script（整体代码）、setTimeout、setInterval、setImmediate、I/O、UI rendering、xhr</p>\n<ol start=\"2\">\n<li><strong>微任务</strong>（microtask）：</li>\n</ol>\n<p>process.nextTick（Nodejs）、Promises、Object.observe、MutationObserver</p>\n<p><br> <strong>同一事件循环tick中微任务总比宏任务先执行</strong></p>\n<p>为了更好的理解 <code class=\"language-text\">microtask</code> 和 <code class=\"language-text\">macrotask</code>，举例下面的代码片段以供理解：</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 请给出下面这段代码执行后，log 的打印顺序</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script start'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">async1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">await</span> <span class=\"token function\">async2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'async1 end'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">async2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'async2 end'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">async1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Promise'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise1'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise2'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script end'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// log 打印顺序：</span>\n<span class=\"token comment\">// script start </span>\n<span class=\"token comment\">// async2 end </span>\n<span class=\"token comment\">// Promise </span>\n<span class=\"token comment\">// script end </span>\n<span class=\"token comment\">// async1 end </span>\n<span class=\"token comment\">// promise1 </span>\n<span class=\"token comment\">// promise2 </span>\n<span class=\"token comment\">// undefined</span>\n<span class=\"token comment\">// setTimeout</span></code></pre></div>\n<p>为什么会出现上面的顺序问题呢？原因是浏览器会根据任务性质不同，将不同的任务源塞进不同的队列中，由于任务源会分为微任务和宏任务，浏览器对两种不同任务源队列中的毁掉函数的读取机制不同（浏览器 event loop 执行机制），造成上述代码的顺序问题。</p>\n<p><br>详细说明：</p>\n<ul>\n<li>执行同步任务：首先遇到了 console.log，输出 script start。</li>\n<li>解析至 async1() ， async1 被放入执行栈，进入 async1 内部，</li>\n</ul>\n<blockquote>\n<p>这里的 await 可能不太好理解，我们可以换一种写法。</p>\n</blockquote>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 这边的 await 可能不太好理解，我换成了另一种写法</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">async1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">async2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">res</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'async1 end'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">async2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'async2 end'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>发现 async1 内部调用了 async2，于是继续进入 async2，并将 async2 推入执行栈，碰到了 console.log， 于是输出 按 async2 end。</p>\n<ul>\n<li>在 async2 函数执行完毕后，弹出执行栈，并返回了一个 promise，此时由于这个 promise 已经变成了 resolve 状态，于是 async1 then 被放入了 microtask 队列。</li>\n<li>遇到 setTimeout0， 等待 0ms 后放入  宏任务队列（macrotask）。</li>\n<li>继续执行，遇到 promise， New Promise的内部注册的回调是立即执行的，进入内部，碰到 console.log，输出 Promise， 将第一个 then 回调放入 microtask 队列，碰到第二个 then 回调，继续推入 microtask 队列中。</li>\n<li>执行到最后一行，输出 script end。</li>\n<li>自此，第一轮的事件循环Tick中的任务执行完成，开始执行下一个循环中的微任务队列。检查微任务队列，发现有3个微任务，依次是：console.log('async1 end')、console.log('promise1')、console.log('promise2') ，于是 event loop 会将这三个回调以此取到主线程执行，输出 async1 end、 promise1、promise2。</li>\n<li>此时 microtask 队列为空，浏览器开始重新渲染（如果有 DOM操作的话），然后再次启动新的事件循环 tick，检查宏任务队列中有个 setTimeout，立即执行输出 setTimeout。</li>\n</ul>\n<h4 id=\"什么是-event-loop\" style=\"position:relative;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-event-loop\" aria-label=\"什么是 event loop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什么是 event loop？</h4>\n<p>js event loop 即是事件循环，是运行在浏览器环境/Node 环境中的一种消息通信机制，它是主线程之外的独立线程。\n当主线程内需要执行某些可能导致线程阻塞的耗时操作时（比如请求发送与接收响应、文件 I/O、数据计算）主线程会注册一个回调函数并抛给 event loop线程进行监听，自己则继续往下执行，一旦消息返回并且主线程空闲的情况下，event loop 会及时通知主线程，执行对应的回调函数获取信息，以此达到非阻塞的目的。<br>\n简而言之，主线程从 “任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。（主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查 microtask 队列是否为空（执行完一个任务的具体标志是函数执行栈为空）， 如果不为空则会一次性执行完所有的 microtask，然后再进入下一个循环去任务队列中取下个任务执行。）</p>\n<p><br>详细说明：</p>\n<ul>\n<li>选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会跳转至微任务的执行步骤。</li>\n<li>将事件循环的当前运行宏任务设置为已选择的宏任务。运行宏任务。</li>\n<li>将事件循环的当前运行任务设置为 null。</li>\n<li>将运行完的宏任务从宏任务队列中移除。</li>\n<li>微任务（microtask）步骤：进入 microtask 检查点。\n<ul>\n<li>设置进入 microtask 检查点的标志为 true。</li>\n<li>当事件循环的微任务不为空时：选择一个最先进入 microtask 队列的 microtask</li>\n<li>设置事件循环的当前运行任务为为已选择的 microtask。运行 microtask。</li>\n<li>设置事件循环的当前运行状态为 null。</li>\n<li>将运行结束的 microtask 从 microtask 队列中移除</li>\n<li>对于相应的事件循环的每个环境设置对象（environment settings object），通知他们哪些 promise 为 rejected。</li>\n<li>清理 indexDB 的事务。</li>\n<li>设置进入 microtask 的检查点的标志为 false。</li>\n</ul>\n</li>\n<li>更新界面渲染。</li>\n<li>返回上面第一步。</li>\n</ul>\n<blockquote>\n<p>⚠️注意: 同一次事件循环中，微任务永远在宏任务之前执行。 当前执行栈执行完毕时会立即先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件执行。</p>\n</blockquote>\n<p>图示：\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/overpurple.io/static/5581a141608420589f83c82c006b2e17/385bc/event_loop.webp\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRmAAAABXRUJQVlA4IFQAAADwAwCdASoUAAoAPtFWpEuoJKOhsAgBABoJQBOiP/wHkTAClPimnD4YAP72CbdT9pML1xFdohktd8WCtgSmtYQGv+wiU4w+nzF7Ch1TcI3YBymwAAA='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image\"\n        title=\"\"\n        src=\"/overpurple.io/static/5581a141608420589f83c82c006b2e17/8aab1/event_loop.webp\"\n        srcset=\"/overpurple.io/static/5581a141608420589f83c82c006b2e17/81b7c/event_loop.webp 158w,\n/overpurple.io/static/5581a141608420589f83c82c006b2e17/6ea66/event_loop.webp 315w,\n/overpurple.io/static/5581a141608420589f83c82c006b2e17/8aab1/event_loop.webp 630w,\n/overpurple.io/static/5581a141608420589f83c82c006b2e17/385bc/event_loop.webp 810w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>接下来我们来思考下面代码的运行顺序：</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script start'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout---0'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout---200'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'inner-setTimeout---0'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise5'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise3'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script end'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// log 输出顺序：</span>\n<span class=\"token comment\">// script start</span>\n<span class=\"token comment\">// script end</span>\n<span class=\"token comment\">// promise1</span>\n<span class=\"token comment\">// promise2  ❌  promise3 ✅ // 第二个then方法 会重新放进下一个 microtask 中执行。  </span>\n<span class=\"token comment\">// promise3   ❌  promise2 ✅ // promise3 跟 promise1 在同一个 microtask 中执行，故先执行。</span>\n<span class=\"token comment\">// setTimeout---0</span>\n<span class=\"token comment\">// setTimeout---200</span>\n<span class=\"token comment\">// promise5</span>\n<span class=\"token comment\">// inner-setTimeout---0</span></code></pre></div>\n<p>详细说明下，js 引擎是如何执行这段代码的：</p>\n<ul>\n<li>首先循序执行完主进程上的同步任务，故依次输出 script start 和 script end。</li>\n<li>接着遇到 setTimeout0，它的作用是在 0ms 后将回调函数放到宏任务队列中（这个任务会在下一次事件循环中执行）。</li>\n<li>接着遇到 setTimeout200， 它的作用是在 200ms 后将回调函数放在宏任务队列中（这个任务会在下一次的事件循环中执行）。</li>\n<li>同步任务执行完之后，首先检查是否有微任务（microtask）队列，发现 microtask 队列不为空，执行第一个 promise 的 then 回调，输出 promise1。然后执行第三个 promise 的 then 回调，输出 promise3，由于第一个 promise 的 .then() 返回的仍然是 promise，所以第二个 .then() 会被放到 microtask 队列中（在下一次事件循环中执行），继续执行，输出 promise2</li>\n<li>此时 microtask 队列为空，进入下一个事件循环，检查 microtask 队列，队列为空，检查宏任务队列，发现有 setTimeout0，输出 setTimeout---0，进入下以此事件循环。</li>\n<li>检查宏任务队列， 发现有 setTimeout200，输出setTimeout---200。</li>\n<li>接着遇到 setTimeout inner 回调，将回调函数放到宏任务队列中（下次循环中执行），检查微任务队列，发现 promise回调，立即执行，输出 promise5.</li>\n<li>此时 microtask 为空，进入下一个事件循环，检查宏任务队列，发现 setTimeout inner 回调，立即执行输出 inner-setTimeout---0。</li>\n</ul>\n<br>\n<p><strong>如果想更好地上手体验 javascript 的 事件循环 的交互步骤， 可以使用可视化工具 <a href=\"http://latentflip.com/loupe/?code=Y29uc29sZS5sb2coJ3N0YXJ0JykKbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0ZWQpewogICAgY29uc29sZS5sb2coJ1Byb21pc2UtMScpCiAgICByZXNvbHZlKCkKfSkudGhlbihmdW5jdGlvbihkYXRhKXsKICAgIGNvbnNvbGUubG9nKCdQcm9taXNlLTEnKQp9KQpzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsKICBjb25zb2xlLmxvZygndGltZW91dCcpOwp9LCAxMDAwKTsKUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7CiAgY29uc29sZS5sb2coJ3Byb21pc2UnKTsKfSk7CmNvbnNvbGUubG9nKCdlbmQnKTsKCg%3D%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\" title=\"Loupe 是一个小可视化工具，可帮助您了解 JavaScript 的调用堆栈/事件循环/回调队列如何相互交互\">Loupe</a></strong></p>\n<blockquote>\n<p>结尾：为什么需要 event loop？</p>\n</blockquote>\n<p>因为 javascript 是单线程的，这就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时比较长的话，后一个任务就不得不一直等着。为了协调事件（event）、用户交互（user interaction）、脚本（script）、渲染（rendering）、网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）</p>\n</details>\n<details open>\n<summary>\n<h3 id=\"nodejs-中的事件循环\" style=\"position:relative;\"><a href=\"#nodejs-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\" aria-label=\"nodejs 中的事件循环 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NodeJS 中的事件循环</h3>\n</summary>\n<p>NodeJS 中也是循环+任务队列的流程以及微任务优先于宏任务，大致表现和浏览器一致的。不过它与浏览器也有一些差异，并且新增了一些任务类型和任务阶段。下面我们来了解下 NodeJS 中的时间循环流程。</p>\n<h4 id=\"nodejs-中的异步方法\" style=\"position:relative;\"><a href=\"#nodejs-%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95\" aria-label=\"nodejs 中的异步方法 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NodeJS 中的异步方法</h4>\n<p>因为都是基于 V8 引擎，浏览器包含的异步方式在 NodeJS 中也是一样的。另外 NodeJS 中还有一些其他的常见异步形式：</p>\n<ul>\n<li>文件 I/O： 异步加载本地文件</li>\n<li>setImmediate()：与 setTimeout 设置 0ms 类似，在某些同步任务完成后立马执行。</li>\n<li>process.nextTick()： 在某些同步任务完成后立马执行。</li>\n<li>server.close、socket.on/socket.close 等：关闭回调。</li>\n</ul>\n</details>\n</details>\n<blockquote>\n<p>参考 <a href=\"https://juejin.cn/post/7164224261752619016\">面试必问之 JS 事件循环（Event Loop）</a></p>\n</blockquote>","frontmatter":{"title":"Interview Topic","date":"October 17, 2023","description":"the front-end advanced interview questions"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFevent-loop\">Js事件循环(Event Loop)</a></p>\n<ul>\n<li>\n<p><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8event-loop\">浏览器Event Loop</a></p>\n<ul>\n<li><a href=\"#javascript-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6\">JavaScript 的运行机制</a></li>\n<li><a href=\"#javascript-%E4%B8%AD%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1\">javaScript 中有两种异步任务</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-event-loop\">什么是 event loop？</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#nodejs-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\">NodeJS 中的事件循环</a></p>\n<ul>\n<li><a href=\"#nodejs-%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95\">NodeJS 中的异步方法</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/use-react-native/"},"frontmatter":{"title":"The development and use of ReactNative"}},"next":{"fields":{"slug":"/Nietzsche/"},"frontmatter":{"title":"Nietzsche's Poetry"}}},"pageContext":{"id":"544d0c45-84c1-5b30-8d46-d4f1d59d75d0","previousPostId":"6d5f630f-f24c-597c-b171-934e9c8dbb8b","nextPostId":"1c160d53-0ffc-5eea-95c2-63784f30cfa4"}},"staticQueryHashes":["2787180309","3666494887"],"slicesMap":{}}